use dicom_core::DataDictionary;
use dicom_dictionary_std::tags::{
    ANATOMICAL_ORIENTATION_TYPE, BODY_PART_EXAMINED, LATERALITY, MODALITY, PATIENT_POSITION,
    PROTOCOL_NAME, SERIES_DATE, SERIES_DESCRIPTION, SERIES_INSTANCE_UID, SERIES_NUMBER,
    SERIES_TIME,
};
use dicom_object::InMemDicomObject;
use helper::element_opt_to_str;
use std::convert::TryFrom;
use Error;

/// The module specifies the Attributes that identify and describe
/// general information about the Series within a Study.
#[derive(Clone, Debug, Default, PartialEq)]
pub struct GeneralSeries {
    /// Date the series was started.
    pub date: String,
    /// Time the series was started.
    pub time: String,
    /// Type of equipment used to acquire the images or data in the series.
    pub modality: String,
    /// Description of the series
    pub description: String,
    ///The anatomical orientation type used in Instances generated by this equipment.
    pub anatomical_orientation_type: String,
    /// Description of the part of the body that was exam examined.
    pub body_part_examined: String,
    /// Description of the parameters under which the series was performed.
    pub protocol_name: String,
    /// Description of the position of the patient relative to the equipment.
    pub patient_position: String,
    /// Unique identifier of the series.
    pub instance_uid: String,
    /// A number that identifies this series.
    pub number: String,
    /// Laterality of (paired) body part examined.
    pub laterality: String,
}

impl<D> TryFrom<&InMemDicomObject<D>> for GeneralSeries
where
    D: DataDictionary + Clone,
{
    type Error = Error;

    fn try_from(obj: &InMemDicomObject<D>) -> Result<Self, Self::Error> {
        Ok(GeneralSeries {
            date: element_opt_to_str(obj, SERIES_DATE, "")?.to_string(),
            time: element_opt_to_str(obj, SERIES_TIME, "")?.to_string(),
            modality: obj.element(MODALITY)?.string()?.to_string(),
            description: element_opt_to_str(obj, SERIES_DESCRIPTION, "")?.to_string(),
            anatomical_orientation_type: element_opt_to_str(obj, ANATOMICAL_ORIENTATION_TYPE, "")?
                .to_string(),
            body_part_examined: element_opt_to_str(obj, BODY_PART_EXAMINED, "")?.to_string(),
            protocol_name: element_opt_to_str(obj, PROTOCOL_NAME, "")?.to_string(),
            patient_position: element_opt_to_str(obj, PATIENT_POSITION, "")?.to_string(),
            instance_uid: element_opt_to_str(obj, SERIES_INSTANCE_UID, "")?.to_string(),
            number: element_opt_to_str(obj, SERIES_NUMBER, "")?.to_string(),
            laterality: element_opt_to_str(obj, LATERALITY, "")?.to_string(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dicom_core::VR;
    use dicom_object::mem::InMemElement;

    #[test]
    fn general_series_try_from() {
        let mut obj = InMemDicomObject::new_empty();
        let _ = obj.put_element(InMemElement::new(SERIES_DATE, VR::DA, "20230729"));
        let _ = obj.put_element(InMemElement::new(SERIES_TIME, VR::TM, "23:59:59"));
        let _ = obj.put_element(InMemElement::new(MODALITY, VR::CS, "CT"));
        let _ = obj.put_element(InMemElement::new(
            SERIES_DESCRIPTION,
            VR::LO,
            "series description",
        ));
        let _ = obj.put_element(InMemElement::new(
            ANATOMICAL_ORIENTATION_TYPE,
            VR::CS,
            "BIPED",
        ));
        let _ = obj.put_element(InMemElement::new(BODY_PART_EXAMINED, VR::CS, "cerebrum"));
        let _ = obj.put_element(InMemElement::new(PROTOCOL_NAME, VR::CS, "protocol"));
        let _ = obj.put_element(InMemElement::new(PATIENT_POSITION, VR::CS, "HFS"));
        let _ = obj.put_element(InMemElement::new(SERIES_INSTANCE_UID, VR::UI, "1.2.3.4"));
        let _ = obj.put_element(InMemElement::new(SERIES_NUMBER, VR::IS, "12"));
        let _ = obj.put_element(InMemElement::new(LATERALITY, VR::CS, "L"));
        let res = GeneralSeries::try_from(&obj);
        assert!(res.is_ok());
        let expected = GeneralSeries {
            date: "20230729".to_string(),
            time: "23:59:59".to_string(),
            modality: "CT".to_string(),
            description: "series description".to_string(),
            anatomical_orientation_type: "BIPED".to_string(),
            body_part_examined: "cerebrum".to_string(),
            protocol_name: "protocol".to_string(),
            patient_position: "HFS".to_string(),
            instance_uid: "1.2.3.4".to_string(),
            number: "12".to_string(),
            laterality: "L".to_string(),
        };
        let sop = res.unwrap();
        assert_eq!(expected, sop);
    }

    #[test]
    fn general_series_try_from_no_optional() {
        let mut obj = InMemDicomObject::new_empty();
        let _ = obj.put_element(InMemElement::new(MODALITY, VR::CS, "CT"));
        let _ = obj.put_element(InMemElement::new(PATIENT_POSITION, VR::CS, "HFS"));
        let _ = obj.put_element(InMemElement::new(SERIES_INSTANCE_UID, VR::UI, "1.2.3.4"));
        let _ = obj.put_element(InMemElement::new(SERIES_NUMBER, VR::IS, "12"));
        let res = GeneralSeries::try_from(&obj);
        assert!(res.is_ok());
        let expected = GeneralSeries {
            date: "".to_string(),
            time: "".to_string(),
            modality: "CT".to_string(),
            description: "".to_string(),
            anatomical_orientation_type: "".to_string(),
            body_part_examined: "".to_string(),
            protocol_name: "".to_string(),
            patient_position: "HFS".to_string(),
            instance_uid: "1.2.3.4".to_string(),
            number: "12".to_string(),
            laterality: "".to_string(),
        };
        let sop = res.unwrap();
        assert_eq!(expected, sop);
    }
}
